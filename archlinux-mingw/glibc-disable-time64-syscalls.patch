diff --git a/sysdeps/unix/sysv/linux/clock_adjtime.c b/sysdeps/unix/sysv/linux/clock_adjtime.c
index 764a60b9bf..85d0d77892 100644
--- a/sysdeps/unix/sysv/linux/clock_adjtime.c
+++ b/sysdeps/unix/sysv/linux/clock_adjtime.c
@@ -32,10 +32,6 @@ __clock_adjtime64 (const clockid_t clock_id, struct __timex64 *tx64)
 # endif
 	return INLINE_SYSCALL_CALL (clock_adjtime64, clock_id, tx64);
 #else
-  int ret = INLINE_SYSCALL_CALL (clock_adjtime64, clock_id, tx64);
-  if (errno != ENOSYS)
-    return ret;
-
   if (tx64->modes & ADJ_SETOFFSET
       && ! in_time_t_range (tx64->time.tv_sec))
     {
diff --git a/sysdeps/unix/sysv/linux/clock_getres.c b/sysdeps/unix/sysv/linux/clock_getres.c
index 5f6955ab10..a009178131 100644
--- a/sysdeps/unix/sysv/linux/clock_getres.c
+++ b/sysdeps/unix/sysv/linux/clock_getres.c
@@ -41,23 +41,6 @@ __clock_getres64 (clockid_t clock_id, struct __timespec64 *res)
 #else
   int r;
   /* Old 32-bit ABI with possible 64-bit time_t support.  */
-# ifdef __NR_clock_getres_time64
-  /* Avoid issue a __NR_clock_getres_time64 syscall on kernels that do not
-     support 64-bit time_t.  */
-  static int time64_support = 1;
-  if (atomic_load_relaxed (&time64_support) != 0)
-    {
-#  ifdef HAVE_CLOCK_GETRES64_VSYSCALL
-      r = INLINE_VSYSCALL (clock_getres_time64, 2, clock_id, res);
-#  else
-      r = INLINE_SYSCALL_CALL (clock_getres_time64, clock_id, res);
-#  endif
-      if (r == 0 || errno != ENOSYS)
-	return r;
-
-      atomic_store_relaxed (&time64_support, 0);
-    }
-# endif
   /* Fallback code that uses 32-bit support.  */
   struct timespec ts32;
 # ifdef HAVE_CLOCK_GETRES_VSYSCALL
diff --git a/sysdeps/unix/sysv/linux/clock_gettime.c b/sysdeps/unix/sysv/linux/clock_gettime.c
index bfe3823b68..04b7602777 100644
--- a/sysdeps/unix/sysv/linux/clock_gettime.c
+++ b/sysdeps/unix/sysv/linux/clock_gettime.c
@@ -42,23 +42,6 @@ __clock_gettime64 (clockid_t clock_id, struct __timespec64 *tp)
 #else
   int r;
   /* Old 32-bit ABI with possible 64-bit time_t support.  */
-# ifdef __NR_clock_gettime64
-  /* Avoid issue a __NR_clock_gettime64 syscall on kernels that do not
-     support 64-bit time_t.  */
-  static int time64_support = 1;
-  if (atomic_load_relaxed (&time64_support) != 0)
-    {
-#  ifdef HAVE_CLOCK_GETTIME64_VSYSCALL
-      r = INLINE_VSYSCALL (clock_gettime64, 2, clock_id, tp);
-#  else
-      r = INLINE_SYSCALL_CALL (clock_gettime64, clock_id, tp);
-#  endif
-      if (r == 0 || errno != ENOSYS)
-	return r;
-
-      atomic_store_relaxed (&time64_support, 0);
-    }
-# endif
   /* Fallback code that uses 32-bit support.  */
   struct timespec tp32;
 # ifdef HAVE_CLOCK_GETTIME_VSYSCALL
diff --git a/sysdeps/unix/sysv/linux/clock_nanosleep.c b/sysdeps/unix/sysv/linux/clock_nanosleep.c
index cc7a09569d..c6160d1384 100644
--- a/sysdeps/unix/sysv/linux/clock_nanosleep.c
+++ b/sysdeps/unix/sysv/linux/clock_nanosleep.c
@@ -46,16 +46,6 @@ __clock_nanosleep_time64 (clockid_t clock_id, int flags, const struct __timespec
   r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64, clock_id,
                                flags, req, rem);
 #else
-# ifdef __NR_clock_nanosleep_time64
-  r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64, clock_id,
-                               flags, req, rem);
-
-  if (! INTERNAL_SYSCALL_ERROR_P (r))
-    return 0;
-  if (INTERNAL_SYSCALL_ERRNO (r) != ENOSYS)
-    return INTERNAL_SYSCALL_ERRNO (r);
-# endif /* __NR_clock_nanosleep_time64 */
-
   if (! in_time_t_range (req->tv_sec))
     {
       __set_errno (EOVERFLOW);
diff --git a/sysdeps/unix/sysv/linux/clock_settime.c b/sysdeps/unix/sysv/linux/clock_settime.c
index ebda871f4c..097ee03d81 100644
--- a/sysdeps/unix/sysv/linux/clock_settime.c
+++ b/sysdeps/unix/sysv/linux/clock_settime.c
@@ -38,11 +38,6 @@ __clock_settime64 (clockid_t clock_id, const struct __timespec64 *tp)
 # endif
   return INLINE_SYSCALL_CALL (clock_settime64, clock_id, tp);
 #else
-# ifdef __NR_clock_settime64
-  int ret = INLINE_SYSCALL_CALL (clock_settime64, clock_id, tp);
-  if (ret == 0 || errno != ENOSYS)
-    return ret;
-# endif
   if (! in_time_t_range (tp->tv_sec))
     {
       __set_errno (EOVERFLOW);
diff --git a/sysdeps/unix/sysv/linux/utimensat.c b/sysdeps/unix/sysv/linux/utimensat.c
index eb16f0f3d5..22eb171e42 100644
--- a/sysdeps/unix/sysv/linux/utimensat.c
+++ b/sysdeps/unix/sysv/linux/utimensat.c
@@ -34,11 +34,6 @@ __utimensat64_helper (int fd, const char *file,
 # endif
   return INLINE_SYSCALL (utimensat_time64, 4, fd, file, &tsp64[0], flags);
 #else
-# ifdef __NR_utimensat_time64
-  int ret = INLINE_SYSCALL (utimensat_time64, 4, fd, file, &tsp64[0], flags);
-  if (ret == 0 || errno != ENOSYS)
-    return ret;
-# endif
   if (tsp64
       && (! in_time_t_range (tsp64[0].tv_sec)
           || ! in_time_t_range (tsp64[1].tv_sec)))
